; reader

; symbol syntax table. Maps chars to a pair holding function to be applied
; and symbol precedence. The function accepts two params: the entire symbol
; and the position where the matching char is. The symbol precedence is a
; positive floating point number.
(def (mk-ssyntax-table) (table))

; add ssyntax to current context
(def (add-ssyntax c prec f)
  (let stb (table-ref (rep (current-ctx)) 'ssyntax-table)
    (table-sref stb c (cons f prec)))) 

; expand symbol s, if it has symbol syntax
; it's up to the registerd ssyntax functions to recursively call
; ssyntax-expand on generated symbols
(def (ssyntax-expand s)
  (withs (stb (table-ref (rep (current-ctx)) 'ssyntax-table)
          rep (string s)
          ln (string-length rep))
    (let winner ((afn (pos winner max-prec)
                   ; find the symbol syntax character with the highest
                   ; precedence
                   (if (is pos ln)
                     winner
                     (let p (table-ref stb (string-ref rep pos))
                       (if (and p (f> (cdr p) max-prec))
                         (self (+ pos 1) (cons (car p) pos) (cdr p))
                         (self (+ pos 1) winner max-prec)))))
                  0 nil -1.0)
      (if winner
        ((car winner) s (cdr winner))
        s))))

; split a symbol in two parts at position pos
; character at position pos is left out
; !! converting back and forth between symbols
; !! and strings is *not* cheap.  Better to stick
; !! with strings until you're sure the string is
; !! just a completely plain symbol, then convert
; !! once.
; !! or not, since reading doesn't need to be
; !! fast, but I suspect it's much easier to
; !! handle strings.
(def (split-sym s pos)
  (withs (s (string s)
          ln (string-length s)
          left (string-build pos)
          right (string-build (- ln (+ pos 1))))
    ((afn (i)
       (when (< i ln)
         (if (< i pos) (string-sref left i (string-ref s i))
             (> i pos) (string-ref right (- i (+ pos 1)) (string-ref s i)))
         (self (+ i 1)))) 0)
    (cons (s-to-sy left) (s-to-sy right))))

; create a ssyntax function that splits the symbol in two and calls f
; passing the two ssyntax-expanded sides
(def (mk-binary-ssyntax f)
  (fn (s pos)
    (if (or (is pos 0) (is pos (string-length (sy-to-s s))))
      (err:string "binary syntax must be in the middle of a symbol: " s)
      (let sides (split-sym s pos)
        (f (ssyntax-expand (car sides)) (ssyntax-expand (cdr sides)))))))

; convenient wrapper around mk-binary-ssyntax
(mac info (def-binary-ssyntax name (left right) . body)
  `(= ,name (mk-binary-ssyntax (fn (,left ,right) ,@body))))

; get current context
(def (current-ctx)
  ; current context is stored in a process local variable
  ; !! a process might want to maintain multiple
  ; !! independent contexts.
  ; !! how about *passing in* the current context instead?
  ; !! we also need to fix the accepted shortcut for
  ; !! "context": arc-f uses "cxt", much of the code
  ; !! here uses "ctx".
  (table-ref (<common>proc-locals) 'current-ctx))

; get the current read table
(def (ctx-read-table)
  (table-ref (rep (current-ctx)) 'read-table))

; many reader functions stop on some special characters
; it's up to these functions to stop, i.e. it isn't compulsory
; like whitespace, parenthesis, etc.
; this special list is part of the current context

; add a "blocking" character to the current list
(def (ctx-block-on c)
  ; use a table for faster lookups
  (table-sref (table-sref (rep (current-ctx)) 'block-on) c t))

; tells if c is a blocking character in the current context
(def (should-block c)
  (table-ref (table-sref (rep (current-ctx)) 'block-on) c))

; get the current context and initialise it with
; default read table
(def (init-default-read-ctx ctx)
  (let ctx (rep ctx)
    (table-sref ctx 'block-on (table))
    (table-sref ctx 'ssyntax-table (mk-ssyntax-table))
    (let read-table (table)
      ; TODO: add entries here
      (table-sref ctx 'read-table read-table))))

; !! another idea:
; !! each read function returns either a nil,
; !! or a cons cell containing the read object
; !! the cons cell can be reused by the list-reading
; !! read function (handler for left-paren), and in
; !! the general case, an object will be read in as
; !! part of a list anyway.
; !! uniq symbols in hl might not be cheap: creating
; !! one may require at least 2 interprocess messages.
; !! throwing away cons cells might be cheaper!
; The read table maps character to read functions
; each read function accepts the matched character,
; the input stream and an object meaning "nothing" (a uniq symbol)
; it returns the read object or the special object
; "nothing"
; the read table must have at least one entry mapping the object 't
; to a special catch-all function, called when there is no other
; matching function

; find reader function for character c
(def (get-read-fn c)
  (let read-table (ctx-read-table)
    (or (table-ref read-table c)
        (table-ref read-table t))))

; main reader loop
(def (base-read in (o eof))
  (let c (readc in)
    (if (is c nil) ; eof
      eof
      (withs (read-fn (get-read-fn c)
              nothing (uniq)
              res (read-fn c in nothing))
        (if (is res nothing)
          ; nothing read, keep going
          (base-read in eof)
          res)))))

; a simple read table entry: ignore the character
(def (ignore c in nothing)
  nothing)

; count lines
(def (eol c in nothing)
  (ctx-inc-line-num)
  nothing)

; skip a comment up to end of line
(def (comment c in nothing)
  (if (is (peekc in) #\newline)
    nothing ; done
    (do 
      (readc in) ; throw away
      (comment c in nothing))))

; tells if c is a digit
(def (adigit c)
  (and (>= (c-to-i c) (c-to-i #\0)) (<= (c-to-i c) (c-to-i #\9))))

; read a number (integer or floating point)
; FIXME: add support for inf, nan, floats with exponent (e.g. 1.2e10)
(def (read-num c in nothing)
  (with (sign (if (is c #\-) -1 1)
         n (if (or (is c #\-) (is c #\+)) 0 (- (c-to-i c) (c-to-i #\0))))
    (= c (readc in)) ; next
    (while (adigit c)
      (= n (+ (* n 10) (- (c-to-i c) (c-to-i #\0))))
      (= c (readc in)))
    (if (is c #\.) ; floating point
      (let p 10.0
        (= c (readc in))
        (while (adigit c)
          (= n (+ n (/ (- (c-to-i c) (c-to-i #\0)) p)))
          (= p (* p 10))
          (= c (readc in)))))
    (unreadc in) ; last character read isn't part of the number
    ; FIXME: if last character read isn't blocking, read up to a
    ; blocking char and return a symbol 
    (* sign n)))



(let escape-table (listtab '(#\" #\") '(#\\ #\\) '(#\n #\newline) '(#\t #\tab))
  (def (escape-char c)
    (let res (table-ref escape-table c)
      (if res
        res 
        (err:string "Don't know how to escape char " c)))))

; FIXME: add support for unicode chars in the form \uNNNN
(def (read-string c in nothing)
  (with (escape-next nil
         res nil)
    (while (do (= c (readc in))
               (no (and (is c #\") (no escape-next))))
      (unless c (err "eof found while reading string"))
      (if 
        escape-next (do 
                      (= escape-next nil) 
                      (= res (cons (escape-char c) res)))
       (is c #\\) (= escape-next t)
       (no (is c #\")) (= res (cons c res))))
    (coerce (rev res) 'string)))

(def (read-sym c in nothing)
  (let res nil
    (while (do (= c (readc in)) (and c (no (should-block c))))
      (= res (cons c res)))
    (ssyntax-expand (s-to-sy (coerce (rev res) 'string)))))

(def (read-# c in nothing)
  (let next (readc in)
    ; TODO: change if with table based approach
    (if
      (is next #\\) (read-char next in nothing)
      (do
        ; default action: read as a symbol
        (unreadc in) ; push #\\ back
        (read-sym c in nothing)))))

(let name->char (listtab '((<>newline #\newline)
                           (<>tab #\tab)
                           (<>null #\null)
                           (<>space #\space)
                           (<>\ #\\))) ; map char names to actual chars
  (def (read-char c in nothing)
    (= c (readc in))
    (if (should-block (peekc in))
      c ; straight char
      (do
        ; TODO: add check for unicode chars (like #\u12AF)
        ; named char, read the name as a symbol
        (withs (word (read-sym c in nothing)
                res (table-ref name->char word))
          (unless res
            (err:string "Unknown char name: " word))
          res)))))

; ~a
(def (ssyntax-complement s pos)
  (if (is pos 0)
          ; !! make sure that built-in ssyntax expansions are *not*
          ; !! packaged, because an interface might redefine them.
          ; !! this also means that ssyntax expansion must
          ; !! occur *before* package contexting.
    (list (unpkg 'complement) (ssyntax-expand (cdr (split-sym s 0))))
    (err:string "~ found in the middle of the symbol: " s)))

; a:b
(def-binary-ssyntax ssyntax-compose (l r)
  (list (unpkg 'm-compose) l r))

; a.b
(def-binary-ssyntax ssyntax-call-one-arg (l r)
  (list l r))

; a!b
(def-binary-ssyntax ssyntax-call-quoted (l r)
  (list l (list (unpkg 'quote) r)))
