; reader

; symbol syntax table. Maps chars to a pair holding function to be applied
; and symbol precedence. The function accepts two params: the entire symbol
; and the position where the matching char is. The symbol precedence is a
; positive floating point number.
(def (mk-ssyntax-table) (table))

; add ssyntax to current context
(def (add-ssyntax c prec f)
  (let stb (table-ref (current-ctx) 'ssyntax-table)
    (table-sref stb c (cons f prec)))) 

; expand symbol s, if it has symbol syntax
; it's up to the registerd ssyntax functions to recursively call
; ssyntax-expand on generated symbols
(def (ssyntax-expand s)
  (withs (stb (table-ref (current-ctx) 'ssyntax-table)
          rep (string s)
          ln (string-length rep))
    (let winner ((afn (pos winner max-prec)
                   ; find the symbol syntax character with the highest
                   ; precedence
                   (if (is pos ln)
                     winner
                     (let p (table-ref stb (string-ref rep pos))
                       (if (and p (f> (cdr p) max-prec))
                         (self (+ pos 1) (cons (car p) pos) (cdr p))
                         (self (+ pos 1) winner max-prec)))))
                  0 nil -1.0)
      (if winner
        ((car winner) s (cdr winner))
        s))))

; split a symbol in two parts at position pos
; character at position pos is left out
(def (split-sym s pos)
  (withs (s (string s)
          ln (string-length s)
          left (string-build pos)
          right (string-build (- ln (+ pos 1))))
    ((afn (i)
       (when (< i ln)
         (if (< i pos) (string-sref left i (string-ref s i))
             (> i pos) (string-ref right (- i (+ pos 1)) (string-ref s i)))
         (self (+ i 1)))) 0)
    (cons (s-to-sy left) (s-to-sy right))))

; create a ssyntax function that splits the symbol in two and calls f
; passing the two ssyntax-expanded sides
(def (mk-binary-ssyntax f)
  (fn (s pos)
    (if (or (is pos 0) (is pos (string-length (sy-to-s s))))
      (err:string "binary syntax must be in the middle of a symbol: " s)
      (let sides (split-sym s pos)
        (f (ssyntax-expand (car sides)) (ssyntax-expand (cdr sides)))))))

; convenient wrapper around mk-binary-ssyntax
(mac info (def-binary-ssyntax name (left right) . body)
  `(= ,name (mk-binary-ssyntax (fn (,left ,right) ,@body))))

; get current context
(def (current-ctx)
  ; current context is stored in a process local variable
  (table-ref (<common>proc-locals) 'current-ctx))

; get the current read table
(def (ctx-read-table)
  (table-ref (current-ctx) 'read-table))

; get current file name
(def (ctx-file-name)
  (table-ref (current-ctx) 'file-name))

; !! you don't need this - the port interface has a
; !! <hl>port-line which keeps track of line numbers
; !! there's also a <hl>port-name for file names;
; !! this is easier handled by the port interface
; current line count
; get
(def (ctx-line-num)
  (table-ref (current-ctx) 'line-num))
; inc
(def (ctx-inc-line-num)
  (let ctx (current-ctx)
    (table-sref ctx (+ (table-ref ctx 'line-num) 1))))

; many reader functions stop on some special characters
; it's up to these functions to stop, i.e. it isn't compulsory
; like whitespace, parenthesis, etc.
; this special list is part of the current context

; add a "blocking" character to the current list
(def (ctx-block-on c)
  ; use a table for faster lookups
  (table-sref (table-sref (current-ctx) 'block-on) c t))

; tells if c is a blocking character in the current context
(def (should-block c)
  (table-ref (table-sref (current-ctx) 'block-on) c))

; get the current context and initialise it with
; default read table
(def (init-default-read-ctx ctx file-name)
  (table-sref ctx 'file-name file-name)
  (table-sref ctx 'line-num 0)
  (table-sref ctx 'block-on (table))
  (table-sref ctx 'ssyntax-table (mk-ssyntax-table))
  (let read-table (table)
    ; TODO: add entries here
    (table-sref ctx 'read-table read-table)))

; The read table maps character to read functions
; each read function accepts the matched character,
; the input stream and an object meaning "nothing" (a uniq symbol)
; it returns the read object or the special object
; "nothing"
; the read table must have at least one entry mapping the object 't
; to a special catch-all function, called when there is no other
; matching function

; find reader function for character c
(def (get-read-fn c)
  (let read-table (ctx-read-table)
    (or (table-ref read-table c)
        (table-ref read-table t))))

; main reader loop
(def (base-read in (o eof))
  (let c (readc in)
    (if (is c nil) ; eof
      eof
      (withs (read-fn (get-read-fn c)
              nothing (uniq)
              res (read-fn c in nothing))
        (if (is res nothing)
          ; nothing read, keep going
          (base-read in eof)
          res)))))

; a simple read table entry: ignore the character
(def (ignore c in nothing)
  nothing)

; count lines
(def (eol c in nothing)
  (ctx-inc-line-num)
  nothing)

; skip a comment up to end of line
(def (comment c in nothing)
  (if (is (peekc in) #\newline)
    nothing ; done
    (do 
      (readc in) ; throw away
      (comment c in nothing))))

; tells if c is a digit
(def (adigit c)
  (and (>= (c-to-i c) (c-to-i #\0)) (<= (c-to-i c) (c-to-i #\9))))

; read a number (integer or floating point)
(def (read-num c in nothing)
  (with (sign (if (is c #\-) -1 1)
         n (if (or (is c #\-) (is c #\+)) 0 (- (c-to-i c) (c-to-i #\0))))
    (= c (readc in)) ; next
    (while (adigit c)
      (= n (+ (* n 10) (- (c-to-i c) (c-to-i #\0))))
      (= c (readc in)))
    (if (is c #\.) ; floating point
      (let p 10.0
        (= c (readc in))
        (while (adigit c)
          (= n (+ n (/ (- (c-to-i c) (c-to-i #\0)) p)))
          (= p (* p 10))
          (= c (readc in)))))
    (unreadc in) ; last character read isn't part of the number
    ; FIXME: if last character read isn't blocking, read up to a
    ; blocking char and return a symbol 
    (* sign n)))

; ~a
(def (ssyntax-complement s pos)
  (if (is pos 0)
    (list '<hl>complement (ssyntax-expand (cdr (split-sym s 0))))
    (err:string "~ found in the middle of the symbol: " s)))

; a:b
(def-binary-ssyntax ssyntax-compose (l r)
  (list '<hl>compose l r))

; a.b
(def-binary-ssyntax ssyntax-call-one-arg (l r)
  (list l r))

; a!b
(def-binary-ssyntax ssyntax-call-quoted (l r)
  (list l (list '<axiom>quote r)))
