; implementation of packages, ported from the scheme version in hl-arc-f

(in-package impl)
(using <hl>v1)

; NOTES:
; be very careful of the separation between
; <hl> and <common> .  <common> cannot be
; sent across machines.  <hl> can.  This
; usually means that <hl> must be wrappers
; that call <common>, because <common> must
; be provided by all machines.
;
; (def (<common>foo x)
;            ; implementation specific, so cannot
;            ; be sent across machines.
;   (let foo (<impl>foo)
;     foo))
; (def (<hl>foo x)
;   ; call the implementation-specific
;   ; function; all implementations should
;   ; have it, but its contents will vary
;   ; across implementations.
;   (<common>foo x))

; create a new empty package
(def (pkg name)
  (tag 'pkg (list 
              (table) ; mapping: unpackaged symbol -> symbol 
              (table) ; mapping: packaged interface symbol -> 
                      ;          list of interface members
              name)))

(def (apkg x)
  (isa x 'pkg))

; mapping: package name symbol -> package object
(def pkgs* (table))

; t if s is a symbol with explicit package name
(def (pkg-sym s)
  (and (asym s)
       (pkg-str (string s))))

(def (pkg-str s)
  (and (> (len s) 2)
       (is (s 0) #\<)
       (find #\> (cut s 1))))

; get symbol without package
(def (unpkg s)
  (if (pkg-sym s)
    (cut s (+ (find #\> s) 1))
    s))

; get package name of symbol
(def (pkg-of s)
  (if (pkg-sym s)
    (cut s 1 (fund #\> s))))

