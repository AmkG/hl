
(in-package impl)
(import <hl>def def)
(import <hl>let let)
(import <hl>with with)
(import <hl>withs withs)
; three-arg-form only
(import <axiom>if if)
; single symbol assigment form only
(import <axiom>set =)
(import <axiom>cons cons)
(import <axiom>car car)
(import <axiom>cdr cdr)
; no destructuring
(import <axiom>lambda fn)
(import <axiom>tag tag)
(import <axiom>type type)
(import <axiom>rep rep)
(import <common>spawn spawn)
(import <common>check-messages check-messages)
(import <common>wait-message wait-message)
(import <common>handle-message handle-message)
(import <hl>list list)
(import <hl>polymorph polymorph)
(import <hl>err err)

(def (<common>port-wrap ob name)
  (tag '<hl>port
       (tag '<hl>shared-port
            (<impl>port-wrap-proc ob name))))

(withs ()
  (def (<impl>port-wrap-proc ob name)
    ; on error, all replies become (==> pid tid e h)
    ; ('<hl>check pid tid k)
    ;   (==> pid tid field-exists)
    ;   ; field-exists is t if the field k exists, nil otherwise
    ; ('<hl>exec pid tid k args)
    ;   (==> pid tid rv)
    ;   ; rv is the return value of the function-like
    ;   ; of the field k, when applied to args
    ; ('<hl>lock pid tid)
    ;   (==> pid tid )
    ;   ; locks the port
    ;   ; should also link the port process to
    ;   ; the requesting process
    ; ('<hl>unlock pid tid)
    ;   ; no response. decrements the lock counter
    (spawn
      (withs (ln   1
              loop ())))))

(def (<hl>port-wrap ob . rest)
  ((fn (name)
     (<common>port-wrap ob name))
   (if rest
       (if (cdr rest)
           (err (tag '<hl>apply "too many arguments"))
           (car rest))
       nil)))

