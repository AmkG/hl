; utility functions necessary to run the compiler

(in-package impl)
(import <axiom>if if)
(import <axiom>lambda fn)
(import <axiom>is is)
(import <axiom>set =)
(import <axiom>tag tag)
(import <hl>mac mac)
(import <axiom>car car)
(import <axiom>cdr cdr)
(import <axiom>cons cons)
(import <axiom>i+ +)
(import <axiom>i/ /)
(import <axiom>i- -)
(import <axiom>imod imod)
(import <axiom>i< <)

(= list (fn args args))
(= cadr (fn (x) (car (cdr x))))

; mac
(= mac (tag 'mac
            (fn (name-and-args . body)
              (list '<axiom>set (car name-and-args)
                                (list 'tag 'mac
                                      (cons 'fn (cons (cons '<hl>macro-info (cdr name-and-args)) body)))))))

(mac (def name-and-args . body)
  ; TODO: use gvl
  (if (is (type name-and-args) '<hl>cons)
    (list '<axiom>set (car name-and-args)
                      (cons 'fn (cons (cdr name-and-args) body)))
    (list '<axiom>set name-and-args body)))

(def (cddr x) (cdr (cdr x)))

(def (no x) (if x nil t))

(def (isa x tp) (is (type x) tp))

(def (acons x) (isa x '<hl>cons))

(def (atom x) (no (acons x)))

(def (isnt a b) (no (is a b)))

(def (caris lst x) (is (car lst) x))

(def (alist x) (or (isa x 'nil) (isa x '<hl>cons)))

(def (mem x lst)
  (if lst
    (if (is x (car lst)) t (mem c (cdr lst)))))

; AmkG: this will be moved, probably to a "scanners.hl"
(defm (len (t x cons))
  ((afn (lst acc)
     (if lst
       (self (cdr lst) (+ acc 1))
       acc))
   x 0))

; coerce
; TODO: maybe use polymorphic 'defm instead of table based approach
; almkglor: I agree, mostly. my intent is that instead of 'coerce,
; we have a set of functions which mean "convert to specific type".
; i.e. instead of (coerce foo 'int) --> (int foo)

(let coerce-table (table)
  (def (coerce what into)
    (if (isa what into)
      what
      (let f (table-ref coerce-table (cons (type what) into))
        (if f
          (f what)
          (err (string "Can't coerce " what " into " into))))))

  (def (def-coerce a b f)
    (table-sref coerce-table (cons a b) f)))

(def-coerce 'char 'int [c-to-i _])
(def-coerce 'int 'char [i-to-c _])
(def-coerce 'char 'string string)
(def-coerce 'char 'sym [s-to-sy (string _)])
(def-coerce 'int 'string string)
(def-coerce 'num 'string string)
(def-coerce 'string 'sym [s-to-sy _])
(def-coerce 'string 'cons [str-to-lst _ 0])
(def-coerce 'cons 'string lst-to-str)
(def-coerce 'nil 'string (fn (x) ""))
(def-coerce 'symbol 'string string)

(def (str-to-lst s pos)
  (if (< pos (string-length s))
    (cons (string-ref s pos) (str-to-lst s (+ pos 1)))
    nil))

; convert a list of chars into a string
(def (lst-to-str lst)
  (withs (n (len lst)
          s (string-build n))
    ((afn (i lst)
       (if lst
         (let x (car lst)
           (if (isa x 'char)
             (string-sref s i x)
             (err (string "Can't coerce a list containing " x " to a string")))
           (self (+ i 1) (cdr lst)))))
     0 lst)
    s))

; TODO: missing def-coerce for string -> int and string -> num

(def (listtab al)
  (let tb (table)
    (each pair al
      (table-sref tb (car al) (cadr al)))
    tb))

(def (maptable f tb)
  (map (fn (k) (f k (table-ref tb k))) (table-keys tb)))

; a lesser 'pos (no testify, no start) enough for the compiler
(def (pos x lst)
  ((afn (i lst)
     (if lst
       (if (is x (car lst)) i (self (+ i 1) (cdr lst)))))
   0 lst))

(def (complement f)
  (fn args (no (apply f args))))
